#+TITLE: Package Builders and =pkgEnt=

* Overview
These routines convert package metadata into build recipes.
This works in combination with =mkNmDir*= for derivations that require ~node_modules/~, and these routines should be be called inside of a recursive =let= block or attrset to allow build ordering to be resolved automatically.

Most of these routines are built on top of =evalScripts= and =nixpkgs.stdenv.mkDerivation= are easy to modify for your own purposes.

=pkgEnt= attrs contain fields for each stage of the build pipeline arriving at =prepared= for their conclusion which is the field used by others when consuming a package.

During the build pipeline there's a fallback behavior for selecting "the most complete" field when =prepared= is not available yet.
All routines will accept =outPath= if it is defined at the top level over any other field, making it a convenient way to force builds to "do what I mean" in the event that you do not want to pass in arbitrary inputs ( you still need to provide the necessary =meta= arguments in that case ). 

* Fields

#+BEGIN_SRC text
  {
    [outPath]    alias for most processed stage. ( ends with "prepared" )
    [tarball]
    source       ( unpacked into "$out" )
    [built]      ( `build'/`pre[pare|publish]' )
    [installed]  ( `gyp' or `[pre|post]install' )
    prepared     ( `[pre|post]prepare', or "most complete" of previous 3 ents )
    TODO: [bin]        ( bins symlinked to "$out" from `source'/`built'/`installed' )
    TODO: [global]     ( `lib/node_modules[/@SCOPE]/NAME[/VERSION]' [+ `bin/'] )
    TODO: module       ( `[/@SCOPE]/NAME' [+ `.bin/'] )
    passthru     ( Holds the fields above + `nodejs', and a few other drvs )
    key          ( `[@SCOPE/]NAME/VERSION' )
    meta         ( package info yanked from locks, manifets, etc - no drvs! )
  }
#+END_SRC
The fields marked "TODO" aren't hard to add; I just haven't had a need to use them so they aren't defined yet; but they may be useful for interoperability with Nixpkgs' existing =nodePackages= ( uses =node2nix= ), and for creating standalone CLI tools as opposed to modules.

** Example MetaEnt for reference ( our input )
This is our "input" which we convert to a build.
This is a good point of reference to know what's available for builders.

Note that all =metaExt= fields are removed by =mkPkgEntSource= essentially "finalizing" the metadata.
Metadata should not be modified past that point, at least not in a way that anyone expects to modify builds.
If you need to modify metadata do it before building ( makes sense ) and if you have to change something regenerate your recipes. 

Users are free to inject additional fields to use with custom builders ( =flocoConfig.meta*Overlays= ) but this is what you get out of the box.

See [[file:../../lib/meta-ent.nix][metaEnt lib]] for more info.

#+BEGIN_SRC nix
  {
    key = "@babel/core/7.18.13";
    ident = "@babel/core";
    version = "7.18.13";
    entFromtype = "package-lock.json(v2)";
    hasBin = false;
    hasBuild = false;
    hasInstallScript = false;
    hasTest = false;
    scoped = true;
    sourceInfo = {
      entSubtype = "registry-tarball";
      hash = "sha512-ZisbOvRRusFktksHSG6pjj1CSvkPkcZq/KHD45LAkVP/oiHJkNBZWfpvlLmX8OtHDG8IuzsFlVRWo08w7Qxn0A==";
      sha512 = "ZisbOvRRusFktksHSG6pjj1CSvkPkcZq/KHD45LAkVP/oiHJkNBZWfpvlLmX8OtHDG8IuzsFlVRWo08w7Qxn0A==";
      type = "tarball";
      url = "https://registry.npmjs.org/@babel/core/-/core-7.18.13.tgz";
    };
    depInfo = { ... };
    names = { src = "..."; built = "..."; installed = "..."; prepared = "..."; test = "..."; ... /* See `libmeta' for full list };
  }
#+END_SRC
