#+TITLE: Package Sets

** Example
A simple build pipeline to build a =package-lock.json(v2/3)= project. This is limited insofar as it doesn't pass an =nmDirCmd= to non-root builders.
Another snippet below shows the current way to deal with non-root packages that have install scripts ( honestly they're rare ).

#+BEGIN_SRC nix
  { lib
  , lockDir
  , flocoConfig

  , pkgsFor
  , mkPkgEntSource
  , mkNmDirPlockV3
  , runCommandNoCC
  , buildPkgEnt
  , installPkgEnt

  , nodejs  ? pkgsFor.nodejs-14_x
  , flocoPackages ? {}
  } @ prev: let

    # Leave these outside of the set to avoid clashing with Nixpkgs 
    callPackageWith  = autoArgs: pkgsFor.callPackageWith ( final // autoArgs );
    callPackagesWith = autoArgs: pkgsFor.callPackagesWith ( final // autoArgs );
    callPackage      = final.callPackageWith {};
    callPackages     = final.callPackagesWith {};

    final = prev // {
      # Override default of v16 used in Nixpkgs 
      nodejs = nodejs-14_x;

      metaSet = lib.libmeta.metaSetFromPlockV3 { inherit lockDir; };
      mkNmDir = mkNmDirPlockV3 {
        # Packages will be pulled from here when their "key" ( "<IDENT>/<VERSION>" )
        # matches an attribute in the set.
        inherit (final) pkgSet;
        # Default settings. These are wiped out if you pass args again.
        copy = false;  # Symlink
        dev  = true;   # Include dev modules
      };

      # FIXME: handle subtrees
      doNmDir = { meta, ... } @ pkgEnt: let
        needsNm = meta.hasBuild || meta.hasInstallScript || meta.hasTest;
      in pkgEnt // ( lib.optionalAttrs needsNm {
        inherit (final) mkNmDir;
      } );

      doBuild = { meta, ... } @ pkgEnt:
        pkgEnt // ( lib.optionalAttrs meta.hasBuild {
          built   = final.buildPkgEnt pkgEnt;
          outPath = build'.built.outPath;
        } );

      doInstall = { meta, ... } @ pkgEnt:
        pkgEnt // ( lib.optionalAttrs meta.hasInstallScript {
          installed = final.installPkgEnt pkgEnt;
          outPath   = installed'.installed.outPath;
        } );

      doTest = { meta, ... } @ pkgEnt:
        pkgEnt // ( lib.optionalAttrs meta.hasTest {
          test = final.testPkgEnt pkgEnt;
        } );

      mkPkgEnt = path: {
        hasBuild
      , hasInstallScript
      , hasBin
      , hasTest ? false
      , ...
      } @ metaEnt: let
        simple = ! ( hasBuild || hasInstallScript || hasBin || hasTest );
        base   = ( mkPkgEntSource metaEnt ) // {
          # Add phony `mkNmDir' as a stub for non-root pkgs.
          #
          # FIXME: you can reuse the root's `node_modules/' dir until you have a
          # smarted solution here.
          # What you'll need to do is use `mkNmDir' to dump trees, and then `cd'
          # to the relevant project to run the build.
          # This is a PITA though because you have to manually arrange the build
          # order or toposort or something.
          #
          # Previously I was writing the ~7-10 packages that actually needed
          # installs to run by hand, honestly they run fine with just NaN in most
          # cases; but if people want "run in any project" then there's no way
          # around sitting down to write a routine to pull-down subtrees from
          # parent dirs to "refocus" a lock.
          mkNmDir = if path == "" then final.mkNmDir else ":";
        };
        done = ( doTest ( doInstall ( doBuild ( doNmDir base ) ) ) );
      in if simple then base // { prepared = base.source; outPath = base.source; }
                   else done;

      # Optionally you can merge these or cherry pick from external packages.
      pkgSet = builtins.mapAttrs final.mkPkgEnt metaSet.__entries;

      # Example of merging ( I recommend using `flocoOverlays' if this pkgSet wants to be used by other flakes )
      flocoPackages = flocoPackages // final.pkgSet;
    };

  in final
#+END_SRC

Overall this pipeline is pretty short; the underlying builders are doing the heavy lifting, we're just arranging them in our preferred order.

*** Nearly an Overlay
Since we've got this example here I want to point out something useful for "composing" a package sets together; in Nix we use a pattern called "overlays" ( see the ones defined in =flake.nix= for examples ).

If you made =final= an arg here at the top, and drop `let' in the body,
you have an overlay that you can compose with other package sets.

If you just want a recursive attrset then take this as it is.

If reading this just helped you understand what an overlay is: High Five!


** Non-Root Install Scripts
I have dealt with this in most projects by manually writing a small snippet to drop in any directoryies I actually need.
Honestly the vast majority of =installScript= run fine without modules as long as you provide =node-gyp= ( provided implicitly by =genericInstall= ) and ocassionally the "NaN" module ( you must provide this explicitly either with =mkNmDir*= or =cp= in a =preConfigure= hook does the trick ).

Those that don't work with those on their own usually take only a few minutes to whip up a tree for.
See the [[file:../../lib/tree.nix][libtree]] documentation and [[file:../mkNmDir/README.org][mkNmDir]] documentation for more extensive examples, but theres a couple:

#+BEGIN_SRC nix
{ mkNmDir ? mkSourceTree, pkgSet, pkgsFor, flocoFetch, genericInstall }: let
  nmDirCmd = mkNmDir {
    # Use something from the package set.
    tree."node_modules/foo" = pkgSet."foo/1.0.0";
    # Use a local path
    tree."node_modules/bar" = flocoFetch { type = "path"; path = "./node_modules/bar"; };
    # Use a `flocoPackage' output from a flake. ( just an arbitrary field )
    tree."node_modules/baz" = ( builtins.getFlake "baz" ).flocoPackages.baz;
    ...
  };
in genericInstall {
  name = "junk-inst-1.0.0";
  src = flocoFetch { type = "path"; path = toString ./.; };
  inherit nmDirCmd;
  buildInputs = [pkgsFor.postgresql];
  ...
}
#+END_SRC

I am going to whip up some extensions to =libtree= soon to make this automatic
but for now that's the way it works.

If you have a package with a large number of deps, make a lock:
#+BEGIN_SRC shell
  NPM_CONFIG_LOCKFILE_VERSION=3 npm i @foo/bar--package-lock-only --ignore-scripts;
  jq '.packages[""]' > ./package.json;
#+END_SRC

This is _nearly_ what =genMeta= does to generate =metaSet= files ( see section below ).

*** Generating =metaSet= using =genMeta= script
Before making this recommendation I want to note: At time of writing, =genMeta= is relatively new and we lack a =lib.libmeta.metaSetFromSerial= routine - but we DO have a =lib.libmeta.metaEntFromSerial= routine ( the actual heavy lifter ). Creating a =metaSet= is as simple as using =builtins.mapAttrs= with =lib.libmeta.metaEntFromSerial= ( filter out any ~__*~ fields first ) and =lib.libmeta.mkMetaSet=; but you'll still be missing info needed by =lib.libtree=. Having said that though, this is currently the least painful way to quickly generate builds for "non-root" installed modules.

With a bit of elbow grease, you can leverage ( or modify ) the script =genMeta= exposed by the top level flake as ~nix run at-node-nix#genMeta -- DESCRIPTOR [FLAGS...]~ to generate the bulk of the metadata you need to define standalone builds for "non-root" installed modules.

This script is going to be extended soon to make this more automatic; but using the short example in the previous section and by taking a quick glance at [[file:../../bin/genMeta.sh][genMeta.sh]] you can easily whip up a build either using a stashed =package-lock.json= + =package.json=, or augmenting the generated =metaSet= with a dump of ~nix eval at-node-nix#lib --apply 'lib: lib.libtree { lockDir = toString ./.; }';~ in the same temporary dir that =genMeta= uses. Again, I'm going to add this soon as a "real" part of the tool-chain, but for now that'll do the trick. FIXME: write the fucking thing.

**** Example using =genMeta= to produce a =node-gyp= build which depends on =NaN=
#+BEGIN_SRC shell
  nix run at-node-nix#genMeta -- @datadog/native-metrics@1.2.0 > meta.nix;
  nix build --impure --expr '
  let
    at-node-nix = builtins.getFlake "at-node-nix";
    inherit (at-node-nix) lib;
    pkgsFor = at-node-nix.legacyPackages.${builtins.currentSystem};
    metaSet = let
      raw     = import ./meta.nix;
      members = builtins.mapAttrs ( k: e:
          if lib.hasPrefix "__" k then e else lib.libmeta.metaEntFromSerial e
        ) raw;
    in lib.libmeta.mkMetaSet members;
    # This is a "full" `pkgEnt', which is superfulous for this example; but useful in
    # real expressions.
    pkgEnt = let
      pkgEntSrc = pkgsFor.mkPkgEntSource metaSet.${metaSet.__meta.rootKey};
      installed = pkgsFor.installPkgEnt ( pkgEntSrc // {
        # We don't care about any other deps for this stage, so just add NaN.
        # Because we have deserialized we don't have info about the original `node_modules/' tree.
        # for that reason we have manually produce the tree ( luckily pretty easy here ).
        nmDirCmd = pkgsFor.mkNmDirLinkCmd {
          handleBindir = false;
          tree."node_modules/nan" = let
            nanKey = builtins.filter ( lib.hasPrefix "nan/" ) ( builtins.attrNames metaSet.__entries );
          in pkgsFor.flocoFetch metaSet.${nanKey}.sourceInfo;
        };
      } );
    in pkgEntSrc // { inherit installed; inherit (installed) outPath; prepared = installed; };
  in pkgEnt
  ';
#+END_SRC

So not the prettiest solution; but since we don't have the tree metadata it'll do the trick.
Having said that we'll almost definitely prefer to dump generated trees for any sizeable dependency graphs.
